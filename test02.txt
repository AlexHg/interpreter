This is a comment. As you can see, we generally use whitespace and nothing else.
It makes programs very clear and easy to understand.


    unit Fork

      new E = Escape⟦(), ()⟧

      sum Result⟦a⟧
        Finished(a)
        Suspended(() ⟶ Fork.Result⟦a⟧)

      Fork⟦a, b⟧(f : () ⟶ a, g : () ⟶ b) : (a, b)
        bind fr to E.Catch(Compose(Finished)(f))(Constant(Suspended))
        bind gr to E.Catch(Compose(Finished)(g))(Constant(Suspended))
        Loop(fr, gr)

      Loop⟦a, b⟧(fr : Fork.Result⟦a⟧, gr : Fork.Result⟦b⟧) : (a, b)
        case fr
          Finished(x)
            (x, Complete(gr))
          Suspended(f)
            case gr
              Finished(y)
                (Complete(f()), y)
              Suspended(g)
                Loop(f(), g())

      Complete⟦a⟧(r : Fork.Result⟦a⟧) : a
        case r
          Finished(x)
            x
          Suspended(f)
            Complete(f())

      Yield : ()
        E.Throw()

    unit Merge⟦t⟧

      new E = Escape⟦t, ()⟧

      With⟦a⟧(x : t, merge : (t, t) ⟶ t)(f : () ⟶ a) : (a, t)
        bind fold to for (y)(k)(x) in E.Catch(Run(f))
          k()(merge(x, y))
        fold(x)

      Run(f : () ⟶ a)()(x : t) : (a, t)
        (f(), x)

      Merge(x : t) : ()
        E.Throw(x)

    unit Get⟦t⟧

      new E = Escape⟦(), t⟧

      With⟦a⟧(x : t)(f : () ⟶ a) : a
        for ()(f) in E.Catch(f)
          f(x)

      Get : t
        E.Throw()

    unit Box⟦t⟧

      new S = Escape⟦t ⟶ t, t⟧

      With⟦a⟧(x : t)(f : () ⟶ a) : a
        bind fold : t ⟶ a to for (modify : t ⟶ t)(k : t ⟶ (t ⟶ a))(x : t) in S.Catch(A(f))
          k(x)(modify(x))
        fold(x)

      A⟦a⟧(f : () ⟶ a)() : t ⟶ a
        Constant(f())

      Modify(f : t ⟶ t) : t
        S.Throw(f)

      Get : t
        Modify(Identity)

      Set(x : t) : ()
        Ignore(Modify(Constant(x)))

    sum Bool
      False
      True

    sum Either⟦a, b⟧
      Left(a)
      Right(b)

    unit Error

      new E = Escape⟦String, ()⟧

      With⟦a⟧(f : () ⟶ a) : Either⟦String, a⟧
        for (x)(_) in E.Catch(Compose(Right)(f))
          Left(x)

      Error⟦a⟧(x : String) : a
        E.Throw(x)
        Unreachable


The IO module provides a mechanism to write strings.


    mod IO

      sub R ↦ Root

      new E = Escape⟦IO.Out, ()⟧

      sum Out
        Wr(String)
        Ex

      With(f : () ⟶ ()) : Output
        E.Catch(A(f))(B)

      A(f : () ⟶ ())() : Output
        f()
        R.Exit

      B(x : IO.Out)(f : () ⟶ Output) : Output
        case x
          Wr(s)
            R.Write(s)(Continue(f))
          Ex
            R.Exit

      Write(x : String) : ()
        E.Throw(Wr(x))

      Exit⟦a⟧ : a
        E.Throw(Ex)
        Unreachable


A text line starts at column 1. It proceeds until there are two empty lines.
This means you can be fairly freeform with paragraphs without causing
interference with code.


    new F = Fork

    Main : Output
      in IO.With
        IO.Write("1")
        bind _ to F.Fork(A, B)
        IO.Write("2")

    A() : ()
      IO.Write("A1")
      F.Yield
      IO.Write("A2")
      IO.Write("A3")

    B() : ()
      IO.Write("B1")
      IO.Write("B2")
      F.Yield
      IO.Write("B3")

    Identity⟦a⟧(x : a) : a
      x

    Compose⟦a, b, c⟧(f : b ⟶ c)(g : a ⟶ b)(x : a) : c
      f(g(x))

    Constant⟦a, b⟧(x : a)(y : b) : a
      x

    Ignore⟦a⟧(x : a) : ()
      ()

    Swap⟦a, b⟧(x : a, y : b) : (b, a)
      (y, x)

    BoolToString(x : Bool) : String
      case x
        True
          "True"
        False
          "False"

    Not(x : Bool) : Bool
      case x
        True
          False
        False
          True

    First⟦a, b⟧(x : a, y : b) : a
      x

    Second⟦a, b⟧(x : a, y : b) : b
      y

    Curry⟦a, b, c⟧(f : (a, b) ⟶ c)(x : a)(y : b) : c
      f(x, y)

    Uncurry⟦a, b, c⟧(f : a ⟶ b ⟶ c)(x : a, y : b) : c
      f(x)(y)

    When(b : Bool)(f : () ⟶ ()) : ()
      case b
        True
          f()
        False
          ()

    Unless(b : Bool)(f : () ⟶ ()) : ()
      When(Not(b))(f)

    Loop⟦a, b⟧(x : a)(f : a ⟶ Either⟦a, b⟧) : b
      case f(x)
        Left(x)
          Loop(x)(f)
        Right(y)
          y

 -- Comments are usually written with a double dash in the gutter, so it is
 -- easy to see comment markers.

 -- sum List⟦a⟧
 --   Nil
 --   Cons(a, List⟦a⟧)
