The minimial program.


    sum List⟦a⟧
      Nil
      Cons(a)

    sum Table⟦a⟧

    sum Symbol

    mod Simple

      sum Program
        Program(Table⟦Fun⟧, Symbol)

      sum Fun
        Fun(Type, Term)

      sum Type

      sum Term
        ApplyTerm(Term, Term)
        LambdaTerm(Symbol, Type, Term)
        StringTerm(String)
        UnreachableTerm

    mod Interpreter

      sum Status
        ExitStatus
        EscapeStatus
        UndefinedStatus
        WriteStatus(String, Status)

      sum Value
        ClosureValue(Value ⟶ Value)
        StringValue(String)

      Interpret(p : Simple.Program) : Status
        Unreachable

      Eval(t : Simple.Term) : Value
        case t
          Simple.ApplyTerm(t1, t2)
            bind v1 to Eval(t1)
            bind v2 to Eval(t2)
            Apply(v1, v2)
          Simple.LambdaTerm(d, _, t)
            bind r to Environment.Get
            for (v) in ClosureValue
              in Environment.With(r)
                in Bind(d, v)
                  Eval(t)
          Simple.StringTerm(x)
            StringValue(x)
          Simple.UnreachableTerm
            E.Throw()

      new E = Escape⟦(), Value⟧

      sum Environment
        Environment(Table⟦Value⟧)

      mod Environment

        With⟦a⟧(_ : Environment)(_ : () ⟶ a) : a
          Unreachable

        Get : Environment
          Unreachable

      Bind⟦a⟧(_ : Symbol, _ : Value)(_ : () ⟶ a) : a
        Unreachable

      Apply(v1 : Value, v2 : Value) : Value
        case v1
          ClosureValue(f)
            f(v2)
          StringValue(_)
            Unreachable





    Main : Output
      IO.With(F)

    F() : ()
      IO.Print(“Hi”)
      IO.Print(“Bye”)


    Blend⟦a, b, c⟧(s : Stream⟦a, b, c⟧)(f : a ⟶ Stream⟦b, a, ()⟧) : c
      case s
        End(x)
          x
        Next(x)(g)
          case f(x)
            End()
              Unreachable
            Next(y)(h)
              Blend(g(y))(h)

    Thunkify⟦a, b⟧(f : a ⟶ b)(x : a)() : b
      f(x)

    Fold⟦a, b, c⟧(s : Stream⟦a, b, c⟧)(f : a ⟶ b) : c
      case s
        End(x)
          x
        Next(x)(g)
          Fold(g(f(x)))(f)

    unit Reader⟦a⟧

      new E = Escape⟦(), a⟧

      With⟦b⟧(x : a)(f : () ⟶ b) : b
        Fold(E.Catch(f))(Constant(x))

    Eternal⟦a, b⟧(x : a)(f : a ⟶ a) : b
      Eternal(f(x))(f)

    unit Box⟦a⟧

      new E = Escape⟦a ⟶ a, a⟧

      With⟦b⟧(x : a)(f : () ⟶ b) : b
        for (g) in Act.With(E.Catch(f))
          for (x) in Eternal(g(x))
            Act.Take(x)(x)

 --   Loop⟦b⟧(s : Stream⟦a ⟶ a, a, b⟧, x : a) : b
 --     case s
 --       End(x)
 --         x
 --       Next(f)(g)
 --         bind y to f(x)
 --         Loop(g(y), y)

      Modify(f : a ⟶ a) : a
        E.Throw(f)

      Get : a
        Modify(Identity)

      Set(x : a) : ()
        Ignore(Modify(Constant(x)))

    Ignore⟦a⟧(x : a) : ()
      ()

    mod Act⟦a, b⟧

      new E = Escape⟦b, a⟧

      With⟦c⟧(s : Stream⟦a, b, c⟧)(f : a ⟶ ()) : c
        for (x) in Blend(s)
          E.Catch(Thunkify(f)(x))

      Take(x : b) : a
        E.Throw(x)

    mod IO

      new E = Escape⟦String, ()⟧

      With(f : () ⟶ ()) : Output
        Loop(E.Catch(f))

      Loop(s : Stream⟦String, (), ()⟧) : Output
        case s
          End()
            Exit
          Next(x)(k)
            Write(x)(Continue(Compose(Loop)(k)))

      Print(x : String) : ()
        E.Throw(x)

    Constant⟦a, b⟧(x : a)(_ : b) : a
      Identity⟦a⟧(x)

    Identity⟦a⟧(x : a) : a
      x

    Compose⟦a, b, c⟧(f : b ⟶ c)(g : a ⟶ b)(x : a) : c
      f(g(x))
